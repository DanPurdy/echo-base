"use strict";

var _to5Helpers = require("6to5-runtime/helpers");

var _core = require("6to5-runtime/core-js");

var _utils = require("./utils");

var promisify = _utils.promisify;
var defer = _utils.defer;


var path = require("path");
var cp = require("child_process");
var semver = require("semver");
var semverRegex = require("semver-regex");
var dargs = require("dargs");
var through = require("through2");
var concat = require("concat-stream");
var which = promisify(require("which"));

var BIN = "sass-convert";
var MINVERS = ">=3.4.5";

/**
 * Execute command in a child process.
 *
 * @see {@link http://nodejs.org/api/child_process.html}
 * @param {String} command
 * @param {Array} args
 * @return {Promise}
 */
function exec(command) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var deferred = defer();
  var childProcess = undefined;

  args.push(function (err, stdout, stderr) {
    if (err) {
      _core.Object.assign(err, {
        message: "" + err.message + " `" + command + "` exited with error code " + err.code,
        stdout: stdout,
        stderr: stderr });

      deferred.reject(err);
    } else {
      deferred.resolve({
        childProcess: childProcess,
        stdout: stdout,
        stderr: stderr });
    }
  });

  childProcess = cp.exec.apply(cp, [command].concat(_to5Helpers.toArray(args)));

  // process.nextTick(() => {
  //   deferred.notify(childProcess);
  // });

  return deferred.promise;
}

var endsWith = function (suffix, str) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
};

/**
 * Custom error for binary check.
 *
 * @param {String} message
 */
var BinaryError = (function (Error) {
  function BinaryError(message) {
    Error.call(this, message);
    // http://bit.ly/1yMzARU
    this.message = message || "Could not find any executable for \"" + BIN + "\". Operation Aborted.";
  }

  _to5Helpers.inherits(BinaryError, Error);

  _to5Helpers.prototypeProperties(BinaryError, null, {
    name: {
      get: function () {
        return "BinaryError";
      },
      configurable: true
    }
  });

  return BinaryError;
})(Error);

/**
 * Custom error for version check.
 *
 * @param {String} message
 */
var VersionError = (function (Error) {
  function VersionError(message) {
    Error.call(this, message);
    // http://bit.ly/1yMzARU
    this.message = message || "Invalid \"" + BIN + "\" version, must be " + MINVERS;
  }

  _to5Helpers.inherits(VersionError, Error);

  _to5Helpers.prototypeProperties(VersionError, null, {
    name: {
      get: function () {
        return "VersionError";
      },
      configurable: true
    }
  });

  return VersionError;
})(Error);

/**
 * Check whether passed binary (Gem) is in $PATH,
 * and check its version.
 *
 * @param {String} bin
 * @return {Promise}
 */
function checkBinary(bin) {
  /**
   * Check for binary min-version.
   *
   * @param {String} str
   * @return {Boolean}
   */
  function checkVersion(str) {
    var version = str.match(semverRegex())[0];
    return semver.satisfies(version, MINVERS);
  }

  /**
   * Check for global binary and version.
   *
   * @return {Promise}
   */
  function checkGlobal() {
    return which(bin).then(function () {
      return exec("" + bin + " -v");
    }, function () {
      throw new BinaryError();
    }).then(function (res) {
      if (!checkVersion(res.stdout)) {
        throw new VersionError();
      }
    });
  }

  /**
   * Check for bundled binary and version.
   *
   * @return {Promise}
   */
  function checkBundle() {
    return which("bundle").then(function () {
      return exec("bundle exec " + bin + " -v");
    }).then(function (res) {
      if (!checkVersion(res.stdout)) {
        throw new VersionError();
      }
      return { bundler: true };
    }, function (err) {
      throw new BinaryError();
    });
  }

  return checkBundle()["catch"](checkGlobal);
}

/**
 * Run binary checks only once.
 *
 * @return {Promise}
 */
function checkBinaryCache() {
  if (!("promise" in checkBinaryCache)) {
    checkBinaryCache.promise = checkBinary(BIN);
  }

  return checkBinaryCache.promise;
}

var Converter = (function () {
  function Converter(options) {
    this.options = options || {};
    this.bundler = false;
  }

  /**
   * Format the `sass-convert` command string.
   *
   * @return {Object}
   */
  Converter.prototype.command = function command() {
    var cmd = "" + (this.bundler ? "bundle exec " : "") + "sass-convert";

    // Add required args.
    var options = _core.Object.assign({}, this.options, {
      stdin: true,
      "no-cache": true });

    // Filter unwanted or erroneous args.
    var allowed = ["from", "to", "dasherize", "indent", "old", "default-encoding", "unix-newlines", "stdin", "no-cache"];

    var args = dargs(options, [], allowed);

    return { cmd: cmd, args: args };
  };

  /**
   * Returns whether file is eligible for convertion.
   *
   * @param {Object} file - Vinyl file Object
   * @return {Boolean}
   */
  Converter.prototype.isTransformable = function isTransformable(file) {
    var ext = path.extname(file.path);
    return (file.isBuffer() || file.isStream()) && endsWith(this.options.from, ext);
  };

  /**
   * Convert file Buffer through `sass-convert` binary.
   *
   * @param {Buffer} file - Vinyl file
   * @param {String} enc - encoding
   */
  Converter.prototype.convertFile = function convertFile(file, enc) {
    var deferred = defer();
    var _ref = this.cmdCache || (this.cmdCache = this.command());
    var cmd = _ref.cmd;
    var args = _ref.args;
    var child = cp.spawn(cmd, args);
    var result = {};

    file.pipe(child.stdin);

    child.stdout.pipe(concat(function (data) {
      result.stdout = data;
    }));

    child.stderr.pipe(concat(function (data) {
      result.stderr = data;
    }));

    child.on("error", deferred.reject);

    child.on("close", function (code, signal) {
      if (code !== 0) {
        var message = "`" + cmd + " " + args.join(" ") + "` failed with code " + code;
        var stderr = Buffer.isBuffer(result.stderr) ? result.stderr.toString() : "";

        deferred.reject({ code: code, message: message, stderr: stderr });
      } else {
        deferred.resolve(result);
      }
    });

    return deferred.promise;
  };

  /**
   * Change file extension to `options.from`.
   *
   * @param {Object} file - Vinyl file
   */
  Converter.prototype.rename = function rename(file) {
    if (!this.options.rename) {
      return;
    }

    var ext = path.extname(file.path);
    file.path = file.path.replace(ext, "." + this.options.to);
  };

  /**
   * Returns a transform stream meant to be piped to a stream
   * of Sass, SCSS or CSS files. Apply convertion if matches.
   *
   * @return {Object} - Stream
   */
  Converter.prototype.stream = function stream() {
    var self = this;

    return through.obj(function (file, enc, cb) {
      var stream = this;

      if (!self.isTransformable(file)) {
        // Pass-through.
        return cb(null, file);
      }

      // Matches `from`, let's convert it.
      checkBinaryCache().then(function (res) {
        self.bundler = res ? res.bundler : false;

        return self.convertFile(file, enc);
      }).then(function (result) {
        file.contents = new Buffer(result.stdout);
        self.rename(file);

        cb(null, file);
      }, function (err) {
        stream.emit("error", err);

        if (self.options.force) {
          // Continue stream chain,
          // but don't pass unconverted chunks.
          return cb();
        }

        // Stop stream chain.
        stream.destroy();
        stream.emit("end");
      });
    });
  };

  return Converter;
})();

module.exports = function (options) {
  return new Converter(options).stream();
};

// Expose custom error constructors.
module.exports.BinaryError = BinaryError;
module.exports.VersionError = VersionError;