"use strict";

var _to5Helpers = require("6to5-runtime/helpers");

/**
 * Checks if given object looks like a logger.
 *
 * If the `debug` function is missing (like for the `console` object),
 * it will be set to an empty function in a newly returned object.
 *
 * If any other method is missing, an exception is thrown.
 *
 * @param {Object} logger
 * @return {Logger}
 * @throws {SassDocError}
 */
exports.checkLogger = checkLogger;
var is = require("./utils").is;
var errors = _to5Helpers.interopRequireWildcard(require("./errors"));

var fmt = require("util").format;
var chalk = require("chalk");

// Special chars.
var chevron = "»";
var checkmark = "✓";
var green = chalk.green(chevron);
var yellow = chalk.yellow(chevron);
var red = chalk.red(chevron);

// Helpers.
var br = function (str) {
  return "[" + str + "]";
}; // Wrap in brackets.

var Logger = (function () {
  function Logger() {
    var verbose = arguments[0] === undefined ? false : arguments[0];
    var debug = arguments[1] === undefined ? false : arguments[1];
    this.verbose = verbose;
    this._stdout = process.stdout;
    this._stderr = process.stderr;
    this._debug = debug;
    this._times = [];
  }

  /**
   * Log arguments into stderr if the verbose mode is enabled.
   */
  Logger.prototype.log = function log() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (this.verbose) {
      var str = fmt.apply(undefined, ["" + green + " " + args.shift()].concat(_to5Helpers.toArray(args)));
      this._stderr.write("" + str + "\n");
    }
  };

  /**
   * Always log arguments as warning into stderr.
   */
  Logger.prototype.warn = function warn() {
    var _this = this;
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    chalkHack(function () {
      var str = fmt.apply(undefined, ["" + yellow + " " + br("WARNING") + " " + args.shift()].concat(_to5Helpers.toArray(args)));
      _this._stderr.write("" + str + "\n");
    });
  };

  /**
   * Always log arguments as error into stderr.
   */
  Logger.prototype.error = function error() {
    var _this = this;
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    chalkHack(function () {
      var str = fmt.apply(undefined, ["" + red + " " + br("ERROR") + " " + args.shift()].concat(_to5Helpers.toArray(args)));
      _this._stderr.write("" + str + "\n");
    });
  };

  /**
   * Init a new timer.
   * @param {String} label
   */
  Logger.prototype.time = function time(label) {
    this._times[label] = Date.now();
  };

  /**
   * End timer and log result into stderr.
   * @param {String} label
   * @param {String} format
   */
  Logger.prototype.timeEnd = function timeEnd(label) {
    var format = arguments[1] === undefined ? "%s: %dms" : arguments[1];
    if (!this.verbose) {
      return;
    }

    var time = this._times[label];
    if (!time) {
      throw new Error("No such label: " + label);
    }

    var duration = Date.now() - time;

    var str = fmt("" + chalk.green(checkmark) + " " + format, label, duration);
    this._stderr.write("" + str + "\n");
  };

  /**
   * Log arguments into stderr if debug mode is enabled (will call all
   * argument functions to allow "lazy" arguments).
   */
  Logger.prototype.debug = function debug() {
    var _this = this;
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!this._debug) {
      return;
    }

    args = args.map(function (f) {
      if (f instanceof Function) {
        return f();
      }

      return f;
    });

    chalkHack(function () {
      var str = fmt.apply(undefined, ["" + chalk.styles.grey.open + "" + chevron + " " + br("DEBUG") + " " + args.shift()].concat(_to5Helpers.toArray(args), [chalk.styles.grey.close]));

      _this._stderr.write("" + str + "\n");
    });
  };

  return Logger;
})();

exports["default"] = Logger;
var empty = exports.empty = {
  log: function () {},
  warn: function () {},
  error: function () {},
  debug: function () {} };function checkLogger(logger) {
  var methods = ["log", "warn", "error"].filter(function (x) {
    return !(x in logger) || !is["function"](logger[x]);
  });

  if (methods.length) {
    var missing = "\"" + methods.join("`, `") + "\"";
    var s = methods.length > 1 ? "s" : "";

    throw new errors.SassDocError("Invalid logger, missing " + missing + " method" + s);
  }

  if ("debug" in logger) {
    return logger;
  }

  return {
    log: logger.log,
    warn: logger.warn,
    error: logger.error,
    debug: empty.debug };
}

/**
 * Chalk don't allow us to create a new instance with our own `enabled`
 * value (internal functions always reference the global export). Here
 * we want to enable it if stderr is a TTY, but it's not acceptable to
 * modify the global context for this purpose.
 *
 * So this hack will set `chalk.enabled` for the time of the synchronous
 * callback execution, then reset it to whatever was its default value.
 */
function chalkHack(cb) {
  var enabled = chalk.enabled;
  chalk.enabled = process.stderr.isTTY;
  cb();
  chalk.enabled = enabled;
}
exports.__esModule = true;