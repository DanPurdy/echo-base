//==============================================================================
//
//  echo-base/defaults/utilities/_functions.scss
//
//  ----------------------------------------------------------------------------
//  Table of contents
//  ----------------------------------------------------------------------------
//  a. Breakpoints
//      1. Setup breakpoints
//      2. Get breakpoint
//      3. Order Breakpoints by size
//      4. Check Mobile Breakpoints
//  b. Palette
//      1. Setup palettes
//      2. Get palette
//  c. Typography
//      1. Merge responsive text element maps
//      2. Merge responsive text custom map with default map
//      3. Get responsive text element properties
//      4. Get breakpoint for responsive text element
//  d. Helpers
//      1. Strip Unit
//      2. Remify
//      3. Rem Calc
//
//
//  @copyright 2015, Loft Digital, www.weareloft.com
//
//==============================================================================

/// $global-page-font-size is the base font size for the document / page.
///
/// @group Global
/// @type String

$global-page-font-size: 16px !default;




//==============================================================================
//  a. Breakpoints
//==============================================================================

//  1. Setup breakpoints
//==============================================================================

/// $breakpoints will hold the result of the merge between the default breakpoints
/// map in breakpoints.scss and the custom breakpoints map from settings.scss.
///
/// @group Breakpoints
/// @type Map

$breakpoints: ();

/// This function will check to see if custom breakpoints have been specified
/// within the $custom-breakpoints map within the _settings.scss file.
///
/// If custom breakpoints have been specified it will return a new map which
/// comprises the contents of $default-breakpoints and $custom-breakpoints.
///
/// If no custom breakpoints are specified only the default breakpoints will be
/// returned.
///
/// @access private
/// @group Breakpoints
/// @return {Map}

@function setup-breakpoints() {

    @if (length($custom-breakpoints) > 0) {
        @return map-merge($default-breakpoints, $custom-breakpoints);
    } @else {
        @return $default-breakpoints;
    }

}



//  2. Get breakpoint
//==============================================================================

/// The break function is used within the Breakpoint mixin.
///
/// It is used to pull the specified key from the breakpoints map, first it sets
/// the map returned from our setup-breakpoints function and assigns it to a
/// $breakpoints variable.
///
/// Using the sass function map-has-key it then looks to see if the key passed
/// to the function exists in the map. If the key does exist it returns that
/// key's value else it returns a sass warning.
///
/// @access private
/// @group Breakpoints
/// @param {String} $key - Breakpoint map key
/// @return {Map}

@function breakpoint($key) {

    @if (length($breakpoints) == 0) {
        $breakpoints: setup-breakpoints();
    }

    @if (map-has-key($breakpoints, $key)) {
        @return map-get($breakpoints, $key);
    } @else {
        @warn "Breakpoint '#{$key}' doesn't exist!";
        @return false;
    }

}



//  3. Order Breakpoints by size
//==============================================================================

/// Returns a sorted list of all the specified breakpoints. This is
/// mostly required when specifying custom breakpoints as we need some way of
/// ordering the custom and default breakpoints once they've been merged to a
/// single map.
///
/// It returns a list of all the breakpoint names specified which can then be used
/// in list order to ensure that all breakpoints are called in the correct order.
///
/// The function loops through the breakpoint map to find the highest value, then
/// it appends this key to the map-list. The process is repeated but if the key
/// already exists in map-list() it is ignored. This provides us a descending
/// ordered list.
///
/// @access private
/// @group Breakpoints
/// @return {List}

@function order-breakpoints() {
    $breakpoint-map: setup-breakpoints();
    $map-list: ();

    @for $i from 1 through length($breakpoint-map) {

        @if($mobile-first == true){
            $current-value: 999999;
        } @else {
            $current-value: 0;
        }

        $current-breakpoint: '';

        @each $key, $value in $breakpoint-map {

            @if (index($map-list, $key) == null) {
                $value: strip-unit($value);

                @if ($mobile-first == true){
                    @if ($value < $current-value) {
                        $current-value: $value;
                        $current-breakpoint: $key;
                    }
                } @else {
                    @if ($value > $current-value) {
                        $current-value: $value;
                        $current-breakpoint: $key;
                    }
                }
            }

        }

        $map-list: append($map-list, $current-breakpoint);
    }

    @return $map-list;
}




//  4. Check Mobile Breakpoints
//==============================================================================

/// Returns a list of breakpoint keys where there is a corresponding responsive text
/// map entry. For example if you create a custom breakpoint but don't specify
/// how a h1 should respond to that in the $responsive-text-custom map in settings
/// then you wouldn't want it to interfere with our default text sizing mixin.
///
/// This is mainly used when $mobile-first is set to true as our default text ratios
/// etc need to accommodate the change and work in a slightly different way without
/// forcing the user to have to specify responsive text points for every breakpoint
/// they may have specified.
///
/// @access private
/// @group Breakpoints
/// @return {List}

@function check-mobile-breakpoints($element, $ordered-breakpoint-keys) {

    $temp-list: ();
    $temp-text-map: setup-responsive-text($element);

    @if (map-has-key($temp-text-map, $element)) {

        $element-map: map-get($temp-text-map, $element);

        @each $item in $ordered-breakpoint-keys {

            @if map-has-key($element-map, $item){
                $temp-list: append($temp-list, $item);
            }
        }

        @return $temp-list;
    } @else {

        @return $ordered-breakpoint-keys;

    }
}




//==============================================================================
//  b. Palettes
//==============================================================================

//  1. Setup palettes
//==============================================================================

/// This function will check to see if custom palettes have been specified
/// within the $custom-palettes map within the _settings.scss file.
///
/// If custom palettes have been specified then this function will return a new
/// map which comprises the contents of $default-palettes and $custom-palettes.
///
/// If no custom palettes are specified only the default palette map will be
/// returned.
///
/// @access private
/// @group Palettes
/// @return {Map}

@function setup-palettes() {
    // Create an empty map holder
    $palettes: ();

    // Include if custom palettes are in use
    @if (length($custom-palettes) > 0) {
        $palettes: map-merge($default-palettes, $custom-palettes);
    } @else {
        $palettes: $default-palettes;
    }

    // Include third-party palette if enabled
    @if ($use-third-party-palette) {
        $palettes: map-merge($palettes, $third-party-palettes);
    }

    @return $palettes;
}



//  2. Get palette
//==============================================================================

/// Retrieves the palette and the specified tone from the global palettes map
///
/// @access public
/// @group Palettes
/// @param {String} $palette - Palette name
/// @param {String} $tone ['base'] - Palette tone
/// @return {Map}

@function palette($palette, $tone: 'base') {
    $palettes: setup-palettes();

    @if (map-has-key($palettes, $palette)) {
        $color: map-get($palettes, $palette);

        @if (map-has-key($color, $tone)) {
            @return map-get($color, $tone);
        } @else {
            @warn "Tone '#{$tone}' doesn't exist for palette '#{$color}'!";
        }

    } @else {
        @warn "Palette '#{$palette}' doesn't exist!";
    }

}




//==============================================================================
//  c. Typography
//==============================================================================

//  1. Merge responsive text element maps
//==============================================================================

/// A variable used throughout our functions file. It will hold the merged
/// responsive text maps.
///
/// @group Responsive Typography
/// @type Map

$responsive-text-map: ();

/// Checks to see if the responsive-text-custom map from settings.scss has any
/// properties defined. If it does it looks to see if the default responsive text map
/// and custom responsive text map have been merged by checking if the specified
/// element is present in this merged map. If it's present the merged map is
/// returned. If not merge-responsive-maps is called to perform the merge. If no
/// custom map exists / has any properties then the defaults map is returned.
///
/// In the event that the custom map has properties but no merged map is found
/// then this function call merge-responsive-maps to perform the merge.
///
/// @access private
/// @group Responsive Typography
/// @param {String} $element - element name
/// @return {Map}

@function setup-responsive-text($element) {

    @if (length($responsive-text-custom) > 0) {

        @if (map-has-key($responsive-text-map, $element)) {
            @return $responsive-text-map;
        } @else {
            $repsonsive-text-map: merge-responsive-maps();
            @return $repsonsive-text-map;
        }

    } @else {
        @return $responsive-text-defaults;
    }

}



//  2. Merge responsive text custom map with default map
//==============================================================================

/// Returns a merged map comprised of the $responsive-text-defaults map from
/// typography.scss and the $responsive-text-custom map from settings.scss
/// allowing us to work with one single map for all our responsive text element
/// needs.
///
/// Loops through each key in the default map and checks to see if that key also
/// exists in the custom map, if it does then we are extending this text
/// elements breakpoints and assosciated properties which will need to be
/// merged.
///
/// If you merge two maps of identical name Sass will overwrite the first,
/// therefore our first step is to rename the key in the default map to 'test'.
/// We then merge this with the corresponding keys map from the custom map
/// giving us a clean new map incorporating properties from both default and
/// custom map.
///
/// If the current key doesn't exist in the custom map we aren't trying to
/// extend this element therefore we just need to merge this from the default
/// map into merged map.
///
/// @access private
/// @group Responsive Typography
/// @return {Map}

@function merge-responsive-maps() {

    @each $key, $value in $responsive-text-defaults {

        @if (map-has-key($responsive-text-custom, $key)) {

            // Assign the defaults map value of the same name to a new map with
            // the key test.

            // If we were to merge two maps with the same key they would
            // overwrite, this way we can be sure that the map will merge.

            $existing-map: (test: map-get($responsive-text-defaults, $key));
            $new-map: ($key: map-merge(map-get($existing-map, test), map-get($responsive-text-custom, $key)));
            $responsive-text-map: map-merge($responsive-text-map, $new-map);
        } @else {
            $new-map: ($key: $value);
            $responsive-text-map: map-merge($responsive-text-map, $new-map);
        }

    }

    @return $responsive-text-map;

}



//  3. Get responsive text element properties
//==============================================================================

/// Utilises the idea from this posting.
///
/// http://maketea.co.uk/2014/11/05/managing-responsive-typography-with-sass.html
///
/// Returns a map of the responsive text properties of the specified element to
/// the text-properties-for function to use. If the specified element isn't
/// found in our responsive text map then it will throw a warning.
///
/// Calls the setup-responsive-text function to make sure we are utilising both
/// the defaults map and the custom map if used.
///
/// @access private
/// @group Responsive Typography
/// @param {String} $element - element to pull properties for
/// @return {Map}

@function text-breakpoints-for($element) {
    $responsive-text: setup-responsive-text($element);

    @if (map-has-key($responsive-text, $element)) {
        @return map-get($responsive-text, $element);
    } @else {
        @warn "'<#{$element}>' doesn't exist in the reponsive text map";
    }

}



//  4. Get breakpoint for responsive text element
//==============================================================================

/// Returns the properties for a certain element at a certain specified
/// breakpoint. Uses the text-breakpoints-for function to pull this elements
/// breakpoints and properties.
///
/// @access private
/// @group Responsive Typography
/// @param {String} $element - element name
/// @param {String} $breakpoint-name - name of the specified breakpoint
/// @return {Map}

@function text-properties-for($element, $breakpoint-name) {
    $element-breakpoints: text-breakpoints-for($element);

    @if (map-has-key($element-breakpoints, $breakpoint-name)) {
        @return map-get($element-breakpoints, $breakpoint-name);
    } @else {
        @return false;
    }

}



// 5. Calculate text size ratios
//==============================================================================

/// As echo base is setup primarily as a desktop first framework we need to do
/// some work to get the default text element sizing ratios working if the user
/// turns on mobile first.
///
/// @access public
/// @group Responsive Typography
/// @param {Int} $ratio - desktop first ratio value
/// @param {Int} $base-ratio - default x-small ratio
/// @return {Int}

@function calc-ratio($ratio, $base-ratio) {
    @if ($mobile-first == true) {
        @return $ratio / $base-ratio;
    } @else {
        @return $ratio;
    }
}




//==============================================================================
//  d. Helpers
//==============================================================================

//  1. Strip Unit
//==============================================================================

/// Strips the units from the passed in value
///
/// @access private
/// @group Helpers
/// @param {String} $value - Value to be stripped of unit
/// @return {Int}

@function strip-unit($value) {
    @return $value / ($value * 0 + 1);
}



//  2. Remify
//==============================================================================

/// Appends the rem unit to the passed in value
///
/// @access private
/// @group Helpers
/// @param {Int} $value - Value to append rem unit to
/// @return {String} - returns the value as a rem unit

@function remify($value, $rem-base) {
    $value: strip-unit($value);

    @if ($value == 0) {
        @return 0;
    } @else {
        @return $value / strip-unit($rem-base) * 1rem;
    }

}



//  3. Rem Calc
//==============================================================================

/// Turns a pixel unit into a rem unit by using the global-page-font-size
///
/// @access public
/// @group Helpers
/// @param {List|Int|String} $values - Values to remify
/// @param {Int} $rem-base [$global-page-font-size] - REM base font size
/// @return {Int}

@function rem-calc($values, $rem-base: $global-page-font-size) {
    $num-vals: length($values);

    @if ($num-vals <= 0) {

        @warn 'You need to supply at least one value to rem-calc';

    } @else if ($num-vals == 1) {
        $val: nth($values, 1);

        @return remify($val, $rem-base);

    } @else if ($num-vals > 4) {

        @warn "You\'ve supplied too many values to rem-calc";

    } @else {
        $rem-values: ();

        @for $i from 1 through $num-vals {
            $rem-values: append($rem-values, remify(nth($values, $i), $rem-base));
        }

        @return $rem-values;
    }

}
